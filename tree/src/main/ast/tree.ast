Set = "new HashSet<>()"
List = "new ArrayList<>()"
Optional = "Optional.empty()"
    
#fromJava = "
public static <name> fromJava(String string) {
    for (<name> operator : values()) {
        if (operator.javaString.equals(string)) {
            return operator;
        }
    }
    throw new IllegalArgumentException();
}
"

Obj {
    PropertyLookup {
        List<String> areas
    }
    
    AnnotationElementValue { }

    TypeName {
        String type
        
        ArrayTypeName {
            int dimensions
        }
    }

    Identifier is LambdaParameter {
        String name
    }
    
    Reference {
        TypeName reference
        
        TypeArgument {
            TypeArgumentWildcard {
                WildcardType type
                
                inside WildcardType {
                    <>
                    EXTENDS
                    SUPER
                }
            }
            TypeArgumentReference {
            }
        }
        
        ExpressionTypeReference is Expression {
        }
        
    }
    

    LambdaParameter {
        LambdaParameterInferred {
            List<Identifier> parameter
        }
    }

    LambdaBody {
    }

    Expression is LambdaBody {

        ExpressionLambda {
            List<LambdaParameter> parameters
            LambdaBody body
        }
        
        ExpressionLiteral<T> is AnnotationValue {
            T value
            
            LiteralBoolean<Boolean> {}
            LiteralCharacter<Character> {}
            LiteralString<String> {}
            LiteralNumeric<T> {
                LiteralFloating<T> {
                    LiteralDouble<Double> {}
                    LiteralFloat<Float> {}
                }
                LiteralInteger<Integer> {}
                LiteralLong<Long> {}
            }
        }
        
        ExpressionAssignment {
            AssignmentOperator operator
            Expression left
            Expression right
            
            inside AssignmentOperator {
                <javaString>
                EQUAL, "="
                MULTIPLY, "*="
                DIVIDE, "/="
                MODULUS, "%="
                ADD, "+="
                SUBTRACT, "-="
                SHIFT_LEFT, "<<="
                SHIFT_RIGHT, ">>="
                ALIGN_RIGHT, ">>>="
                BINARY_AND, "&="
                BINARY_EXCLUSIVE_OR, "^="
                BINARY_INCLUSIVE_OR, "|="
                
                #fromJava
            }
        }
        
        ExpressionClassInstanceCreation {
            TypeName type
            Optional<ClassBody> body
            List<Expression> arguments
            List<TypeArgument> typeArguments
        }
        
        ExpressionName {
            Identifier identifier
        }
        
        ExpressionMethodInvocation {
            Identifier methodName
            Optional<PropertyLookup> methodArea
            List<Expression> arguments
            List<TypeArgument> typeArguments
        }
        
        ExpressionParenthesis {
            Expression expression
        }
        
        ExpressionTernary {
            Expression left
            Expression condition
            Expression right
        }
        
        ExpressionUnary {
            Operator operator
            Expression expression
            
            inside Operator {
                <javaString, formatString>
                PRE_INCREMENT, "++", "++%s"
                PRE_DECREMENT, "--", "--%s"
                POST_INCREMENT, "++", "%s++"
                POST_DECREMENT, "--", "%s--"
                #fromJava
            }
        }
        
        ExpressionLeftRight {
            LeftRightOperator operator
            Expression left
            Expression right
            
            inside LeftRightOperator {
                <javaString>
                ADD, "+"
                SUBTRACT, "-"
                MULTIPLY, "*"
                DIVIDE, "/"
                MODULUS, "%"
                CONDITIONAL_AND, "&&"
                CONDITIONAL_OR, "||"
                CONDITIONAL_LESS_THAN, "<"
                CONDITIONAL_GREATER_THAN, ">"
                CONDITIONAL_LESS_THAN_EQUAL, "<="
                CONDITIONAL_GREATER_EQUAL, ">="
                INSTANCE_OF, "instanceof"
                EQUAL, "=="
                NOT_EQUAL, "!="
                BINARY_SHIFT_LEFT, "<<"
                BINARY_SHIFT_RIGHT, ">>"
                BINARY_ALLIGN_RIGHT, ">>>"
                BINARY_INCLUSIVE_OR, "|"
                BINARY_EXCLUSIVE_OR, "^"
                BINARY_AND, "&"
                
                #fromJava
            }
        }
    }

    StatementElse {
        Optional<Statement> condition
        Expression expression
    }

    Statement {
        StatementControl {
            StatementControlLoop {
                StatementFor {
                    Statement statement
                    StatementBasicFor {
                        Optional<Expression> init
                        Optional<Expression> condition
                        Optional<Expression> update
                    }
                    
                    StatementEnhancedFor {
                        Set<Modifier> variableModifiers
                        Parameter variable
                        Expression expression
                    }
                }
                
                StatementWhile {
                    
                    Expression expression
                    Statement statement
                
                    StatementDoWhile {}
                }
            }
            
            IdentifiableStatement {
                Optional<Identifier> identifier
                
                StatementBreak { }
                StatementContinue { }
            }
            
            StatementReturn {
                Optional<Expression> expression
            }
            
            StatementSwitch {
                Expression expression
            }
            
            StatementSynchronized {
                Expression expression
                Block block
            }
            
            StatementThrow {
                Expression expression
            }
            
            StatementTry {
                Block block
                List<CatchClause> catchClauses
                Optional<Block> finallyBlock
            }
            
            StatementTryWithResources {
            }
            
            StatementIf {
                Statement statement
                Expression expression
                List<StatementElse> elseStatements
            }
            
            StatementCatch {
                MultiParameter parameters
                Block block
            }
        }
        
        StatementAssert {
            Expression assertion
            Optional<Expression> message
        }
        
        Block is LambdaBody {
            List<Statement> statements
        }
        
        StatementEmpty {
        }
        
        StatementExpression {
            Expression expression
        }
        
        StatementLabeled {
            Identifier identifier
            Statement statement
        }
        
        StatementAssert {
            Expression assertion
            Optional<Expression> message
        }
        
        StatementLabeled {
            Identifier identifier
            Statement statement
        }
        
        StatementLocalVariableDeclaration {
            List<Annotation> annotations
            Set<Modifier> modifiers
            TypeName type
            List<Variable> variables
        }
    }

    Annotation {
        TypeName type
        List<AnnotationValue> values
    }

    AnnotationValue {
        ValuePair {
            Identifier identifier
            AnnotationElementValue value
        }
        ValueSingle {
            AnnotationElementValue value
        }
        
    }

    Unit {
        BodyMember {
            TypeMember {
                AnnotationMember {
                }
                
                EnumMember {
                    ClassMember {
                        ClassInitializer {
                            Block block
                            
                            ClassInstanceInitializer {}
                            ClassStaticInitializer {}
                        }
                        
                        Method {
                            MethodHeader header
                            Block body
                        }
                    }
                }
                
                InterfaceMember {
                    InterfaceMethod {
                        MethodHeader header
                        Optional<Block> body
                    }
                }
            }
        }
        
        TypeBody<T> {
            List<T> members
            
            ClassBody<ClassMember> {}
            AnnotationBody<AnnotationMember> {}
            EnumBody<EnumMember> {
                List<EnumConstant> constants
            }
            InterfaceBody<InterfaceMember> {}
        }
        
    }

    Variable {
        Identifier name
        Optional<Expression> initializer
    }

    Modifiable {
        Set<Modifier> modifiers

        CatchClause {
            Identifier identifier
            List<TypeName> catchTypes
            Identifier variable
            Block block
        }
        
        Annotatable {
        
            Set<Annotation> annotations 
            
            Field is ClassMember {
                TypeName type
                List<Variable> variables
            }
            
            Parameter is LambdaParameter {
                TypeName type
                Identifier name
            }
            
            MultiParameter {
                List<TypeName> types
                String name
            }
            
            ConstructorDeclaration is ClassMember {
                TypeName identifier
                List<Parameter> parameters
                List<TypeParameter> typeParameters
                List<TypeName> throwsTypes
                Block body
            }
            
            Identifiable {
                Identifier identifier
                
                TypeParameter {
                    List<TypeName> bounds
                } 
                
                EnumConstant is EnumMember {
                    List<Expression> arguments
                    Optional<ClassBody> body
                }
                
                MethodHeader {
                    TypeName returns
                    List<Parameter> parameters
                    List<TypeName> throwsTypes
                    List<TypeParameter> typeParameters
                }
                
                AnnotationField is AnnotationMember {
                    TypeName type
                    Optional<AnnotationValue> defaultValue
                }
                
                Type<T> is Unit {
                    T body
                    
                    AnnotationType<AnnotationBody> {}
                    
                    SuperInterfaceType<T> {
                        List<TypeName> superInterfaces
                        
                        TypeParameterType<T> {
                            List<TypeParameter> typeParameters
                            
                            Interface<InterfaceBody> {}
                            
                            Class<ClassBody> is ClassMember {
                                Optional<TypeName> superType
                            }
                        }
                        
                        Enum<EnumBody> {}
                    }
                }
            }
        }
    }

    Import {
        String packageName
        String name
        boolean onDemand
        boolean isStatic
    }

    CompilationUnit {
        Optional<String> packageName
        List<Import> importss
        List<Type> types
    }
    
    Modifier {
        <javaString>
        PUBLIC, "public"
        PRIVATE, "private"
        PROTECTED, "protected"
        FINAL, "final"
        STATIC, "static"
        STRICTFP, "strictfp"
        VOLATILE, "volatile"
        ABSTRACT, "abstract"
        SYNCHRONIZED, "synchronized"
        TRANSIENT, "transient"
        NATIVE, "native"
        
        #fromJava
    }
}
