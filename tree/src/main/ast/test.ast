Modifier {
    PUBLIC
    PRIVATE
    PROTECTED
    FINAL
    STATIC
    STRICTFP
    VOLATILE
    ABSTRACT
    SYNCHRONIZED
    TRANSIENT
    NATIVE
}

TypeName {
    String type
    
    ArrayTypeName {
        int dimensions
    }
}

Identifier is LambdaParameter {
    String name
}

TypeArgument {
    TypeArgumentWildcard {
        inside WildcardType {
            EXTENDS
            SUPER
        }
        WildcardType type
    }
    
    TypeArgumentReference {
        TypeName type
    }
}

LambdaParameter {
    LambdaParameterInferred {
        List<Identifier> parameter
    }
}

LambdaBody {
}

Expression is VariableInitializer {

    ExpressionLambda {
        List<LambdaParameter> parameters
        LambdaBody body
    }
    
    ExpressionLiteral<T> {
        T value
        
        LiteralBoolean<Boolean> {}
        LiteralCharacter<Character> {}
        StringLiteral<String> {}
        NumericLiteral<T> {
            FloatingLiteral<T> {
                LiteralDouble<Double> {}
                LiteralFloat<Float> {}
            }
            IntegerLiteral<Integer> {}
            LongLiteral<Long> {}
        }
    }
    
    ExpressionAssignment {
        inside AssignmentOperator {
            EQUAL, "="
            MULTIPLY, "*="
            DIVIDE, "/="
            MODULUS, "%="
            ADD, "+="
            SUBTRACT, "-="
            SHIFT_LEFT, "<<="
            SHIFT_RIGHT, ">>="
            ALIGN_RIGHT, ">>>="
            BINARY_AND, "&="
            BINARY_EXCLUSIVE_OR, "^="
            BINARY_INCLUSIVE_OR, "|="
        }
        
        AssignmentOperator operator
        Expression left
        Expression right
    }
    
    ExpressionClassInstanceCreation {
        TypeName type
        Optional<JClassBody> body
        List<Argument> arguments
        List<TypeArgument> typeArguments
    }
    
    ExpressionName {
        Identifier identifier
    }
    
    ExpressionMethodInvocation {
        Identifier identifier
        List<Argument> arguments
        List<TypeArgument> typeArguments
        Optional<String> methodArea
    }
    
    ExpressionParenthesis {
        Expression expression
    }
    
    ExpressionTernary {
        Expression left
        Expression condition
        Expression right
    }
    
    ExperssionTypeReference {
        TypeName reference
    }
    
    ExpressionUnary {
        Operator operator
        Expression expression
    }
    
    ExpressionLeftRight {
        inside LeftRightOperator {
            ADD, "+"
            SUBTRACT, "-"
            MULTIPLY, "*"
            DIVIDE, "/"
            MODULUS, "%"
            CONDITIONAL_AND, "&&"
            CONDITIONAL_OR, "||"
            CONDITIONAL_LESS_THAN, "<"
            CONDITIONAL_GREATER_THAN, ">"
            CONDITIONAL_LESS_THAN_EQUAL, "<="
            CONDITIONAL_GREATER_EQUAL, ">="
            INSTANCE_OF, "instanceof"
            EQUAL, "=="
            NOT_EQUAL, "!="
            BINARY_SHIFT_LEFT, "<<"
            BINARY_SHIFT_RIGHT, ">>"
            BINARY_ALLIGN_RIGHT, ">>>"
            BINARY_INCLUSIVE_OR, "|"
            BINARY_EXCLUSIVE_OR, "^"
            BINARY_AND, "&"
        }
        
        LeftRightOperator operator
        Expression left
        Expression right
    }
    
    ExpressionMethodInvocation {
        List<TypeArgument> arguments
        Identifier identifier
    }
}

StatementElse {
    Optional<Statement> condition
    Expression expression
}

Statement {
    StatementControl {
        StatementControlLoop {
            StatementFor {
                JStatement statement
                StatementBasicFor {
                    Optional<JExpression> init
                    Optional<JExpression> condition
                    Optional<JExpression> update
                    JStatement statement
                }
                
                StatementEnhancedFor {
                    Parameter variable
                    Statement statement
                }
            }
            
            StatementWhile {
                
                Expression expression
                Statement statement
            
                StatementDoWhile {}
            }
        }
        
        IdentifiableStatement {
            Optional<JIdentifier> identifier
            
            StatementBreak {}
            StatementContinue {}
        }
        
        StatementReturn {
            Optional<JExpression> expression
        }
        
        StatementSwitch {
            Expression expression
        }
        
        StatementSynchronized {
            Expression expression
            Block block
        }
        
        StatementThrow {
            Expression expression
        }
        
        StatementTry {
            Block block
            List<CatchClause> catchClauses
            Optional<JBlock> finallyBlock
        }
        
        StatementTryWithResources {
        }
        
        StatementIf {
            Statement statement
            Expression expression
            List<StatementElse> elseStatements
        }
        
        StatementCatch {
            MultiParameter parameters
            Block block
        }
    }
    
    StatementAssert {
        Expression assertion
        Optional<Expression> message
    }
    
    Block {
        List<Statement> statements
    }
    
    StatementEmpty {
    }
    
    StatementExpression {
        Expression expression
    }
    
    StatementLabeled {
        Identifier identifier
        Statement statement
    }
    
    StatementAssert {
        Expression assertion
        Optional<JExpression> message
    }
    
    StatementLabeled {
        Identifier identifier
        Statement statement
    }
    
    StatementLocalVariableDeclaration {
        List<Annotation> annotations
        Set<Modifier> modifiers
    }
}

Annotation {
    TypeName type
    List<AnnotationValue> values
}

AnnotationValue {
    ValuePair {
        Identifier identifier
        String tempValue
    }
}

Unit {
    BodyMember {
        BodyElementInstantiable {
            ConstructorDeclaration is ClassMember {
                TypeName identifier
                List<Parameter> parameters
                List<TypeName> throws
                Block body
            }
        }
        TypeMember {
            AnnotationMember {
                AnnotationField {
                    List<Annotation> annotations
                }
            }
            
            EnumMember {
                ClassMember {
                    ClassInitializer {
                        JBlock block
                        
                        ClassInstanceInitializer {}
                        ClassStaticInitializer {}
                    }
                    
                    Method {
                        MethodHeader header
                        Block body
                    }
                }
            }
            
            InterfaceMember {
                
            }
        }
    }
    
    TypeBody<T> {
        List<T> members
        
        ClassBody<ClassMember> {}
        AnnotationBody<AnnotationMember> {}
        EnumBody<EnumMember> {
            List<EnumConstant> constants
        }
        InterfaceBody<InterfaceMember> {}
    }
    
    Type<T> is Identifiable {
        T body
        
        AnnotationType<AnnotationBody> {}
        
        TypeSuperInterface<T> {
            List<TypeName> superInterfaces
            
            ClassType<ClassBody> {}
            EnumType<EnumBody> {}
            InterfaceType<InterfaceBody> {}
        }
    }
}

Variable {
    Identifier name
    Optional<VariableInitializer> initializer
}

VariableInitializer {}

Modifiable {
    Set<Modifier> modifiers

    Annotatable {
    
        Set<Annotation> annotations 
        
        Field is BodyElementInstantiable {
            TypeName type
            List<Variable> variables
        }
        
        Parameter {
            TypeName type
            String name
        }
        
        MultiParameter {
            List<TypeName> types
            String name
        }
        
        Identifiable {
            Identifier identifier
            
            EnumConstant is EnumMember {
                List<Expression> arguments
                Optional<ClassBody> body
            }
            
            Class is BodyElement {
                List<Method> methods
            }
            
            MethodHeader is InterfaceMember {
                TypeName returns
                List<Parameter> parameters
                List<TypeName> throwsTypes
            }
        }
    }
}

Import {
    String packageName
    String name
    boolean onDemand
    
    StaticImport {}
}

CompilationUnit {
    Optional<Package> packageName
    List<Import> imports
    List<Type> types
}
